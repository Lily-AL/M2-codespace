-----------
-- Rings --
-----------
-- basic fields/rings
kk = ZZ/32003
--Inverses
3_kk^-1


kk = QQ
kk = GF 8  -- Galois field of 8 elements
  kk_0
  a
  a^3 + a + 1

kk = toField(QQ[i]/(i^2+1))--Field extensions
  i^2
  i

kk = frac(ZZ[a,b,c])--fractions fields
  (a+b)/(c^2-1)

kk = ZZ   -- generally not what you want, as it isn't a field...
--generally you want finite fields for computational time and make positive characteristic p>>0

-- Polynomial rings
R = ZZ/101[a..d]
  R_0 --first generator
  numgens R
  gens R


S = ZZ/101[x_0..x_5]
  x_0 -- a variable
  x = 10 --error because there is not x in that ring
  use S
  x_0
  describe S

T = ZZ/101[a..d, Degrees => {1,3,6,7}]--different grading or multidegrees
  describe T

use S
V = S[a,b,c]--polynomial ring with a polynomial ring as coefficient ring
(x_0+x_1)*a + x_1*b + x_2*c
flattenRing V

-- Quotients of polynomial rings
use S
  U = S/(x_0^2-1, x_1^3-2)
  ring x_0
  gens U
  oo/ring

-- Localizations 
needsPackage "LocalRings"
help  "LocalRings"

-- reals and complexes!
-- major problem: these are only approximate!
-- Can't be used with Groebner bases!
-- BUT: can use NumericalAlgebraicGeometry to find solutions.
RR[x,y] --if you run this you get RR_53 that is the number of bits that the computer gets, so it is not a field
RR_200
CC[x,y]--you can't safely use that CC as the complex geometry but some things around numerical stuff can be done
x + ii*y

-----------------
-- Ideals -------
-----------------
R = ZZ/101[a..d]
I = ideal(a*d-b*c, b^2-a*c, c^2-b*d)--twisted cubic curve
I_0 --first element with the default order
numgens I
gens I

--getting a list from the generators
for i from 0 to numgens I - 1 list I_i
I_*
netList I_* --put everything in a box

--some invariants
dim I
codim I
degree I
hf = hilbertSeries I --fractional function
reduceHilbert hf --you can get the degree for the coefficient of T and the dimension of the power of the denominator
betti res I
regularity I --The top number of the Betti Tally
C=res I
C.dd

-- some operations on ideals
I^2
J = intersect(I, ideal(a,b,c^3))
I == J
I*J
groebnerBasis I

help "Ideal"
----------------
-- Matrices ----
----------------
use R
m = matrix{{a,b,c},{b,c,d}}--row by row
m_(0,0)--getting an element
(transpose m) * m --the output gives you information about the degree, for instance when you get the transpose the degree goes from 1 to -1
numrows m
numcols m
source m --domain
target m --codomain
minors(2, m)
m --the output change the direction because of when you multiply a matrix with a vector you put in the right of a matrix
R^3

----------------
-- Modules -----
----------------
R^1/I -- not R/I...! but use this if you want to treat as a module
coker m
image m
ker m
prune ker m --take a module and gets a free module modulo the relations
Ext^2(coker m, R)
Tor_2(coker m, coker vars R)--usual notations for Tor^k or Tor_k
C = res coker m
C.dd
betti C
-- lot's more you can do...

---------------------------------------------
-- From/to lists, ideals matrices, modules --
---------------------------------------------
-- list to an ideal?
-- ideal to a list?
-- matrix to a list?
-- list(s) to a matrix?
-- ideal to a matrix?
-- matrix to an ideal?
-- generator matrix, relation matrix
I_* --ideal to a list

--list to an ideal
ideal(a,b,c)
ideal{a,b,c}

--matrix to a list
entries m
flatten entries m

--list to a matrix
matrix{{1,2,3}}
matrix pack(3,{1,2,3,4,5,6})

--ideal to a matrix
matrix{I_*}
gens I
mingens I

use R
matrix pack(3,{1_R,2,3,4,5,6})
matrix(R, pack(3,{1,2,3,4,5,6}))

--matrix to an ideal
ideal{a,b,c}
presentation coker m
gens image m

----------------------
-- Exercise  ---------
----------------------
-- A (pure) binomial in a ring R: (monomial) - (monomial)
-- (no extra coefficients), e.g. a^2*b*c - a*d^3
-- Create a function which takes 2 arguments:
--  1. # generators m
--  2. a list of monomials B
-- return an ideal generated by m pure binomials which are differences of monomials in B.
-- randoBinomials = (m, B) -> (
--   )
-- extra credit: check that all the elements of B are monomials all in the same ring.

randoBinomials = (m, B) -> (
  n=length B;
  R={};
  while (length R) < 2*m  do(
    L = random toList(0 .. n-1);
    R = R | {B_(L_0)-B_(L_1),B_(L_1)-B_(L_0)};
    B1 = set R;
    R = toList B1;
  );
  ideal R
)



-- example use:
  R = ZZ/101[a..d]
  B = flatten entries basis(3, R)
  randoBinomials(4, B)

-- some commands you might find useful here:
  random 7 -- gives random integer from 0 to 6
  tally for i from 0 to 10000 list random 7

  size (a^2-b*c+c^2) -- number of monomials
  ring B_0
  ring B_0 == ring B_1 -- not usable for rings!
  ring B_0 === ring B_1



-- exercise: Make another function which gives random monomials and random binomials.

--------------------
-- Exercise 2 ------
--------------------
-- Contest!

-- Investigate ideals generated by 5 quadrics (e.g. binomials) (in what ever number of variables you want).
-- Generating Betti diagram and regularity
-- generate a bunch of ideals
-- calculate the table for each using m=5 degree 2
R2 = ZZ/101[a..d]
B2 = flatten entries basis(2, R2)
BetRes= (m,B2,n) -> (
M={};
for i from 1 to n do(
C= randoBinomials(5, B2);
Reg = regularity C;
Res = res C;
Bet = betti Res;
M = M | {(Reg,Bet)};
aux = set M
);
toList aux
)

Tables = BetRes(2,B2,1000)
#Tables
-- What is the largest regularity of such ideals that you can find?
-- How many different Betti tables can you find?

-- Some possibly useful commands (here, L is a list of ideals_
  L/regularity
  L/(I -> betti res I)
  netList pack(4, M)

  --Questions and Answers

  --get rid of the degree at the beginning of the matrix
R=ZZ/101[vars(0..17)]
gens R 
M=genericMatrix(R,a,3,6)
N=transpose M
N ** R^{-1}--tensoring

--homogeneous matrix
N1 = map(R^6,R^3,N)
isHomogeneous N1
N2 = map(R^6,null,N)
isHomogeneous N2
isWellDefined N1

N3 = map(R^6 ** coker vars R, ,N)
isHomogeneous N3
target N3
isWellDefined N3

--Loops in reverse
for i in reverse toList(3..7) list i^2

--Changing coefficients of a polynomial ring
RQ=QQ(monoid(R))
gens RQ